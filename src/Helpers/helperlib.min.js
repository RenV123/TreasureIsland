export function getRandomNr(t,e){return Math.floor(Math.random()*(e-t)+t)}export function colorShade(t,e){3===(t=t.replace(/^#/,"")).length&&(t=t[0]+t[0]+t[1]+t[1]+t[2]+t[2]);let[h,a,s]=t.match(/.{2}/g);[h,a,s]=[parseInt(h,16)+e,parseInt(a,16)+e,parseInt(s,16)+e],h=Math.max(Math.min(255,h),0).toString(16),a=Math.max(Math.min(255,a),0).toString(16),s=Math.max(Math.min(255,s),0).toString(16);return`#${(h.length<2?"0":"")+h}${(a.length<2?"0":"")+a}${(s.length<2?"0":"")+s}`}export function shuffleArray(t){var e,h,a;for(a=t.length-1;a>0;a--)e=Math.floor(Math.random()*(a+1)),h=t[a],t[a]=t[e],t[e]=h;return t}export class PathWayFinder{constructor(t,e){this._gameboard=t,this._whiteListedTiles=e}findShortestPath(t,e){let h=this._gameboard.getTile(t.x,t.y).pos,a={listOfCheckedSpots:[h],activePaths:[[h]],goodPaths:[],badPaths:[]};return this._findPathRecursive(a,e),a}canFindPathBetweenPoints(t,e){return this.findShortestPath(t,e).goodPaths.length>0}_findPathRecursive(t,e){let h=[];for(;t.activePaths.length>0;){let a=t.activePaths.pop();if(a&&a.length>0){let s=a[a.length-1],o=[this._gameboard.getTile(s.x+1,s.y),this._gameboard.getTile(s.x-1,s.y),this._gameboard.getTile(s.x,s.y+1),this._gameboard.getTile(s.x,s.y-1)],i=!0;o.forEach((s=>{s&&this._whiteListedTiles.includes(s.constructor.name)&&!t.listOfCheckedSpots.includes(s.pos)&&(i=!1,s.pos.equals(e)?t.goodPaths.push([...a,s.pos]):(t.listOfCheckedSpots.push(s.pos),h.push([...a,s.pos])))})),i&&t.badPaths.push(a)}}t.activePaths=h,t.activePaths.length>0&&0==t.goodPaths.length?this._findPathRecursive(t,e):t.goodPaths.length>0&&t.goodPaths.sort(((t,e)=>t.length>e.length))}}